---
title: 面试分享(七).操作系统相关
date: 2019-09-18 18:33:00
tags:
    - Linux
categories: Linux
---
# 操作系统相关
## 什么是socket，网络传输有哪几个层级

### 什么是socket
网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。
![image](http://www.strongsickcat.com:7014/file/dinghuang-blog-picture/6c224f4a20a446230b22bd709422720e0cf3d733.jpg)

建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口;HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。

Socket的英文原义是"孔"或"插座"。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作"套接字"，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。

Socket正如其英文原意那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。

### 网络传输有哪几个层级

所谓的协议就是双方进行数据传输的一种格式。

网络中，一帧以太网数据包的格式：
![image](http://www.strongsickcat.com:7014/file/dinghuang-blog-picture/656312-e4cc3edef27a091d.png)

层级 | 名称 | 包含的协议
---|---|---
7 | 应用层 | 例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP
6 | 表示层 | 例如XDR、ASN.1、SMB、AFP、NCP
5 | 会话层 | 例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets
4 | 传输层 | 例如TCP、UDP、RTP、SCTP、SPX、ATP、IL
3 | 网络层 | 例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25
2 | 数据链路层 | 例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP
1 | 物理层	 | 例如线路、无线电、光纤、信鸽


层级 | 名称 | 功能
---|---|---
7 | 应用层 | 文件传输，电子邮件，文件服务，虚拟终端
6 | 表示层 | 数据格式化，代码转换，数据加密
5 | 会话层 | 解除或建立与别的结点的联系
4 | 传输层 | 提供端对端的接口
3 | 网络层 | 为数据包选择路由
2 | 数据链路层 | 传输有地址的帧以及错误检测功能
1 | 物理层	 | 以二进制数据形式在物理媒体上传输数据

TCP/IP是传输层协议，主要解决数据如何在网络中传输；而HTTP是应用层协议，主要解决如何包装数据。

把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。(可以这样理解:TCP和UDP都是用来传输其他协议的)

而Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。

ip地址

每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。

Internet委员会定义了5种IP地址类型以适合不同容量的网络，即A类~E类。
其中A、B、C3类（如下表格）由InternetNIC在全球范围内统一分配，D、E类为特殊地址

![image](http://www.strongsickcat.com:7014/file/dinghuang-blog-picture/656312-4926f3bcdcdc2369.png)

### TIME_WAIT是什么状态还记得吗，什么情况下网络会出现这个状态
#### 出现原因分析
TCP连接的终止 
TCP建立一个连接至少需要交换三个分组，也因此称之为TCP的三路握手（three-way handshake），然而在TCP终止连接时，由于双方都需要发送一个FIN分节给对端确认，因此TCP终止连接一般是需要交换四个分节。具体来看： 

1、 应用进程（active close）首先调用close，于是导致TCP发送一个FIN分节，表示数据已分送完毕，请求关闭套接字。 

2、 另一端应用进程（passive close）接受收到FIN，并由该端的TCP确认（确认的过程是TCP发送ACK分节给对端套接字）。FIN的接受也作为文件结束符传递给上层应用进程。这里的文件结束符并非应用进程的EOF，在TCP字节流中，EOF的读或写通过收发一个特殊的FIN分节来实现

3、 另端（passive close）应用进程在接受到文件束符后，会调用close关闭它的套接字，这导致该端的TCP也发送了一个FIN分节。 

4、 主动关闭端（active close）接受到这个FIN后，TCP对它进行确认。（TCP发送ACK分节，值得注意的是主动关闭端在未接受到FIN之前，它的状态就是TIME_WAIT）。 

![image](http://www.strongsickcat.com:7014/file/dinghuang-blog-picture/39ffa41f-7d9a-3b5f-b3c3-4dfd3605b121.gif)

综上所述：``TIME_WAIT``状态出现场景是主动关闭端在未接受到FIN之前，它的状态就是``TIME_WAIT``。

#### TCP为什么如此设计
1。防止上一次连接中的包(特别是最后一个ACK包)，迷路后重新出现，影响新连接  （经过2MSL(max segment lifetime)，上一次连接中所有的重复包都会消失）。

2。可靠的关闭TCP连接  在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发
  fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以  主动方要处于 ``TIME_WAIT`` 状态，而不能是 CLOSED 。``TIME_WAIT`` 并不会占用很大资源的，除非受到攻击。还有，如果一方 send 或 recv 超时，就会直接进入 CLOSED 状态。

#### 规避大量出现TIME_WAIT的方法

- ``net.ipv4.tcp_tw_reuse``和``net.ipv4.tcp_tw_recycle``的开启都是为了回收处于``TIME_WAIT``状态的资源。
- ``net.ipv4.tcp_fin_timeout``这个时间可以减少在异常情况下服务器从``FIN-WAIT-2``转到``TIME_WAIT``的时间。
- ``net.ipv4.tcp_keepalive_*``一系列参数，是用来设置服务器检测连接存活的相关配置。

在服务器的日常维护过程中，会经常用到下面的命令：

```
netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'   
```
它会显示例如下面的信息：

```
TIME_WAIT 814
CLOSE_WAIT 1
FIN_WAIT1 1
ESTABLISHED 634
SYN_RECV 2
LAST_ACK 1
```

常用的三个状态是：``ESTABLISHED`` 表示正在通信，``TIME_WAIT`` 表示主动关闭，``CLOSE_WAIT`` 表示被动关闭。

#### 三次握手的详细描述
第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；

第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

#### 为什么要三次握手
既然总结了TCP的三次握手，那为什么非要三次呢？怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢？在谢希仁的《计算机网络》中是这样说的：

> 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

在书中同时举了一个例子，如下：

> “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

这就很明白了，防止了服务器端的一直等待而浪费资源。

#### 四次挥手的详细描述
当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。

1. 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入``FIN_WAIT_1``状态；这表示主机1没有数据要发送给主机2了；
1. 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入``FIN_WAIT_2``状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了；
1. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入``CLOSE_WAIT``状态；
1. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入``TIME_WAIT``状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。

#### 为什么要四次分手
那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。

- ``FIN_WAIT_1``: 这个状态要好好解释一下，其实``FIN_WAIT_1``和``FIN_WAIT_2``状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：``FIN_WAIT_1``状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到``FIN_WAIT_1``状态。而当对方回应ACK报文后，则进入到``FIN_WAIT_2``状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以``FIN_WAIT_1``状态一般是比较难见到的，而``FIN_WAIT_2``状态还有时常常可以用netstat看到。（主动方）
- ``FIN_WAIT_2``：上面已经详细解释了这种状态，实际上``FIN_WAIT_2``状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）
- ``CLOSE_WAIT``：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到``CLOSE_WAIT``状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在``CLOSE_WAIT``状态下，需要完成的事情是等待你去关闭连接。（被动方）
- ``LAST_ACK``: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）
- ``TIME_WAIT``: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到``TIME_WAIT``状态，而无须经过``FIN_WAIT_2``状态。（主动方）
- ``CLOSED``: 表示连接中断。

## 哪些典型的应用用的是UDP？
#### TCP应用
（1）FTP：文件传输协议；

（2）SSH：安全登录、文件传送(SCP)和端口重定向；

（3）Telnet：不安全的文本传送；

（4）SMTP：简单邮件传输协议Simple Mail Transfer Protocol (E-mail)；

（5）HTTP：超文本传送协议 (WWW)；

![image](http://www.strongsickcat.com:7014/file/dinghuang-blog-picture/730e0cf3d7ca7bcb389cf0c8b0096b63f724a875.png)

#### UDP应用
（1）流媒体

采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。基于UDP的协议如WebRTC是极佳的选择。

（2）实时游戏

对实时要求较为严格的情况下，采用自定义的可靠UDP协议，比如Enet、RakNet（用户有sony online game、minecraft）等，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。

采用UDP的经典游戏如FPS游戏Quake、CS，著名的游戏引擎Unity3D采用的也是RakNet。

（3）物联网

2014年google旗下的Nest建立Thread Group，推出了物联网通信协议Thread，完善物联网通信。

全球将近50%的人都在使用互联网，人们不断的追求更快、更好的服务，一切都在变化，在越来越多的领域，UDP将会抢占TCP的主导地位。

（4）QQ 文件传输、QQ语音、QQ视频

对于网络通讯质量要求不高的情况下，要求网络通讯速度能尽量快捷方便，就可以使用UDP技术。


## 内核态和用户态、cas 和 sout 哪个用到了内核态和用户态的切换
究竟什么是用户态，什么是内核态，这两个基本概念以前一直理解得不是很清楚，根本原因个人觉得是在于因为大部分时候我们在写程序时关注的重点和着眼的角度放在了实现的功能和代码的逻辑性上，先看一个例子：

```

void testfork(){  

    if(0 = = fork()){  

         printf(“create new process success!\n”);  

     }  

    printf(“testfork ok\n”);  

 }  
```

这段代码很简单，从功能的角度来看，就是实际执行了一个fork()，生成一个新的进程，从逻辑的角度看，就是判断了如果fork()返回的是则打印相关语句，然后函数最后再打印一句表示执行完整个testfork()函数。代码的执行逻辑和功能上看就是如此简单，一共四行代码，从上到下一句一句执行而已，完全看不出来哪里有体现出用户态和进程态的概念。

如果说前面两种是静态观察的角度看的话，我们还可以从动态的角度来看这段代码，即它被转换成CPU执行的指令后加载执行的过程，这时这段程序就是一个动态执行的指令序列。而究竟加载了哪些代码，如何加载就是和操作系统密切相关了。

### 特权级
熟悉Unix/Linux系统的人都知道，fork的工作实际上是以系统调用的方式完成相应功能的，具体的工作是由sys_fork负责实施。其实无论是不是Unix或者Linux，对于任何操作系统来说，创建一个新的进程都是属于核心功能，因为它要做很多底层细致地工作，消耗系统的物理资源，比如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录页表等等，这些显然不能随便让哪个程序就能去做，于是就自然引出特权级别的概念，显然，最关键性的权力必须由高特权级的程序来执行，这样才可以做到集中管理，减少有限资源的访问和使用冲突。

特权级显然是非常有效的管理和控制程序执行的手段，因此在硬件上对特权级做了很多支持，就Intel x86架构的CPU来说一共有0~3四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查，相关的概念有 CPL、DPL和RPL，这里不再过多阐述。硬件已经提供了一套特权级使用的相关机制，软件自然就是好好利用的问题，这属于操作系统要做的事情，对于 Unix/Linux来说，只使用了0级特权级和3级特权级。也就是说在Unix/Linux系统中，一条工作在级特权级的指令具有了CPU能提供的最高权力，而一条工作在3级特权级的指令具有CPU提供的最低或者说最基本权力。

### 用户态和内核态
现在我们从特权级的调度来理解用户态和内核态就比较好理解了，当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；反之，当程序运行在级特权级上时，就可以称之为运行在内核态。

虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，比如上面例子中的``testfork()``就不能直接调用 ``sys_fork()``，因为前者是工作在用户态，属于用户态程序，而``sys_fork()``是工作在内核态，属于内核态程序。

当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态，比如testfork()最初运行在用户态进程下，当它调用fork()最终触发 sys_fork()的执行时，就切换到了内核态。

#### 用户态和内核态的转换

1）用户态切换到内核态的3种方式

a. 系统调用

这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

b. 异常             

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

c. 外围设备的中断

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。

2）具体的切换操作

从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态的步骤主要包括：

[1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。

[2] 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个

过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一

条指令。

[3] 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始

执行中断处理程序，这时就转到了内核态的程序执行了。